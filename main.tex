\documentclass[12pt, a4paper]{article}

\usepackage{cmap}					
\usepackage[T2A]{fontenc}		
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{tikz}
\usetikzlibrary{arrows}

\begin{document}

\input{k-means.tex}

\section*{Иерархическая кластеризация}


Иерархическая кластеризация выводит иерархию, структуру, которая в целом информативнее, чем набор предсказаний от других видов кластеризации. Иерархическая кластеризация не требует заранее определять количество кластеров, и большинство популярных иерархических алгоритмов является неслучайными. 

Существует два подхода решения задачи иерархической кластеризации — восходящий и нисходящий. Восходящий алгоритм присваивает каждому образцу отдельный кластер, 
а затем объединяет пары наиболее похожих друг на друга кластеров в один, пока не получит кластер со всеми объектами внутри. Нисходящий алгоритм наоборот: 
начинает с большого кластера и далее разделяет кластеры до тех пор, пока в каждом кластере не будет по одному объекту.
Часто иерархическую кластеризацию представляют в форме дендрограмм, 
где схожие объекты содержатся в одинаковых ветвях. Для перевода результата иерархической кластеризации в готовый вид необходимо сделать разрез на определенном уровне. Существует несколько правил для выбора уровня разреза:

\begin{itemize}
\item Выполнить разрез на данном уровне схожести.
\item Сделать разрез там, где разница между двумя уровнями схожести будет максимальной.
\item Зафиксировать строгое количество $K$ кластеров и выбрать соответствующий уровень для разделения.
\end{itemize}
   
\section*{Восходящая кластеризация}
Для начала стоит ввести такое понятие, как расстояние между точками. Существует несколько способов определения расстояний, но наиболее популярно евклидово расстояние, которое и будет далее использоваться:

\[
\||a-b||_2 = \sqrt{\sum_i (a_i-b_i)^2}
\]

Мы будем использовать полносвязную кластеризацию для определения схожести кластеров:

\begin{itemize}
\item В этом подходе схожесть двух кластеров определяется как схожесть их двух наиболее различающихся элементов:
\[
\ d(W_i, W_j) =  \max_{x_i \in W_i, x_j \in W_j} ||x_i - x_j||
\]
где d - некоторая функция схожести, $W_{i, j}$ - два кластера и $x_{i, j}$ - две точки, взятые из каждого кластера. При таком подходе уделяется внимание лишь тем областям, в которых кластеры наиболее близки; игнорируются другие части и общая структура.
Данный подход позволяет создавать компактные кластеры; чувствителен к выбросам.
\end{itemize}

\section*{Пошаговая иллюстрация}

\begin{enumerate}
\item Сначала алгоритм присваивает каждому объекту кластер

\[
\begin{tikzpicture}
    
    \draw (-3.5, 3.5) -- (3.5, 3.5);
    \draw (-3.5, -3.5) -- (3.5, -3.5);
    \draw (-3.5, -3.5) -- (-3.5, 3.5);
    \draw (3.5, 3.5) -- (3.5, -3.5);
        
    \draw (2.5, 2.5) circle (0.12);
    \draw (1.35, 2.25) circle (0.12);
    \draw (1.6, 1.1) circle (0.12);
    \draw (1.95, 1.9) circle (0.12);
    \draw (-2.4, -1.9) circle (0.12);
    \draw (-1.8, -1.3) circle (0.12);
    \draw (-1.95, 2.11) circle (0.12);
    \draw (2.6, -2.4) circle (0.12);
        
    \draw (-2.6, -2.15) rectangle (-2.15, -1.64);
    \draw (-2.05, -1.55) rectangle (-1.55, -1.1);
    \draw[green] (2.2, -2.8) rectangle (3, -2);
    \draw (2.2, 2.2) rectangle (2.8, 2.8);
    \draw[red] (1.023, 1.9) rectangle (1.63, 2.57);
    \draw (1.73, 1.64) rectangle (2.17, 2.13);
    \draw (1.35, 0.83) rectangle (1.85, 1.38);
    \draw[green] (-2.4, 1.6) rectangle (-1.5, 2.55);

\end{tikzpicture}
\]

\item Затем он подсчитывает схожесть (через расстояние) с соседними объектами, и в случае положительного результата объединяется с ближайшими объектами. На этом уровне кластеризации уже можно сделать разрез.

\[
\begin{tikzpicture}
    \draw (-3.5, 3.5) -- (3.5, 3.5);
    \draw (-3.5, -3.5) -- (3.5, -3.5);
    \draw (-3.5, -3.5) -- (-3.5, 3.5);
    \draw (3.5, 3.5) -- (3.5, -3.5);
        
    \draw (2.5, 2.5) circle (0.12);
    \draw (1.35, 2.25) circle (0.12);
    \draw (1.6, 1.1) circle (0.12);
    \draw (1.95, 1.9) circle (0.12);
    \draw (-2.4, -1.9) circle (0.12);
    \draw (-1.8, -1.3) circle (0.12);
    \draw (-1.95, 2.11) circle (0.12);
    \draw (2.6, -2.4) circle (0.12);
        
    \draw[blue] (-2.7, -2.1) rectangle (-1.5, -1.1);
    \draw[green] (2.2, -2.8) rectangle (3, -2);
    \draw[red] (1, 0.83) rectangle (2.8, 2.8);
    \draw[green] (-2.4, 1.6) rectangle (-1.5, 2.55);
\end{tikzpicture}
\]

\item Алгоритм повторяет этот шаг, пока не останется других кластеров. Ближайший объект присоединяет к себе. Здесь он уже захватил отметку из шума.

\[
\begin{tikzpicture}
\draw (-3.5, 3.5) -- (3.5, 3.5);
    \draw (-3.5, -3.5) -- (3.5, -3.5);
    \draw (-3.5, -3.5) -- (-3.5, 3.5);
    \draw (3.5, 3.5) -- (3.5, -3.5);
        
    \draw (2.5, 2.5) circle (0.12);
    \draw (1.35, 2.25) circle (0.12);
    \draw (1.6, 1.1) circle (0.12);
    \draw (1.95, 1.9) circle (0.12);
    \draw (-2.4, -1.9) circle (0.12);
    \draw (-1.8, -1.3) circle (0.12);
    \draw (-1.95, 2.11) circle (0.12);
    \draw (2.6, -2.4) circle (0.12);
        
    \draw[red] (-2.3, 0.83) rectangle (2.8, 2.8);
    \draw[blue] (-2.7, -2.1) rectangle (-1.5, -1.1);
    \draw[green] (2.2, -2.8) rectangle (3, -2);
\end{tikzpicture}
\]

\item Наконец, алгоритм захватывает все точки на плоскости, объединяя их в один единый кластер.

\[
\begin{tikzpicture}
\draw (-3.5, 3.5) -- (3.5, 3.5);
    \draw (-3.5, -3.5) -- (3.5, -3.5);
    \draw (-3.5, -3.5) -- (-3.5, 3.5);
    \draw (3.5, 3.5) -- (3.5, -3.5);
        
    \draw (2.5, 2.5) circle (0.12);
    \draw (1.35, 2.25) circle (0.12);
    \draw (1.6, 1.1) circle (0.12);
    \draw (1.95, 1.9) circle (0.12);
    \draw (-2.4, -1.9) circle (0.12);
    \draw (-1.8, -1.3) circle (0.12);
    \draw (-1.95, 2.11) circle (0.12);
    \draw (2.6, -2.4) circle (0.12);
        
    \draw[red] (-2.7, -2.7) rectangle (2.8, 2.85);
\end{tikzpicture}
\]
\end{enumerate}

\newpage
\section*{Нисходящая кластеризация}
Алгоритм выполняет следующие шаги:

\begin{enumerate}
\item На первом шаге алгоритм присваивает всем объектам один кластер.
\[
\begin{tikzpicture}
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);
        
        \draw (-2.8, -2.8) circle (0.12);
        \draw (-1.75, 2.8) circle (0.12);
        \draw (1, 2.5) circle (0.12);
        \draw (1.9, 1) circle (0.12);
        \draw (1, -1.5) circle (0.12);
        \draw (1.8, -2) circle (0.12);

        \draw[red] (-3, -3) rectangle (3, 3);
\end{tikzpicture}
\]

\item Далее алгоритм находит наименее похожий на другие объект и отделяет его, создав новый кластер. 

\[
\begin{tikzpicture}

        \begin{scope}
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);

        \draw (-2.8, -2.8) circle (0.12);
        \draw (-1.75, 2.8) circle (0.12);
        \draw (1, 2.5) circle (0.12);
        \draw (1.9, 1) circle (0.12);
        \draw (1, -1.5) circle (0.12);
        \draw (1.8, -2) circle (0.12);

        
        \draw[red] (-2.3, -2.3) rectangle (3, 3);
        \draw[blue] (-3, -3) rectangle (-2.6, -2.6);
    \end{scope}
\end{tikzpicture}
\]

\item В исходном кластере алгоритм рассчитывает среднее расстояние для каждого объекта со всеми остальными. Затем рассчитывает расстояние для каждого объектами и всеми объектами, которые находятся в  отдельном кластере. Если первое расстояние больше, то объект переносится во второй кластер. 

\[
\begin{tikzpicture}
        \begin{scope}[yshift=-9cm]
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);

        \draw (-2.8, -2.8) circle (0.12);
        \draw (-1.75, 2.8) circle (0.12);
        \draw (1, 2.5) circle (0.12);
        \draw (1.9, 1) circle (0.12);
        \draw (1, -1.5) circle (0.12);
        \draw (1.8, -2) circle (0.12);

        
        \draw[blue] (-2.5, 0.5) rectangle (3, 3);
        \draw[green] (-3, -3) rectangle (2.8, -1);
    \end{scope}
\end{tikzpicture}
\]

\item Алгоритм повторяет шаг 3., пока объектов с отрицательной разностью не останется.

\item Далее алгоритм повторяет шаги 2-4 для самых больших кластеров. 

\[
\begin{tikzpicture}
        \begin{scope}[yshift=-9cm]
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);

        \draw (-2.8, -2.8) circle (0.12);
        \draw (-1.75, 2.8) circle (0.12);
        \draw (1, 2.5) circle (0.12);
        \draw (1.9, 1) circle (0.12);
        \draw (1, -1.5) circle (0.12);
        \draw (1.8, -2) circle (0.12);

        
        \draw[blue] (-2, 3) rectangle (-1.5, 2.5);
        \draw[green] (0.5, 3) rectangle (2.8, 0);
        \draw[black] (0.5, -1) rectangle (2.5, -2.5);
        \draw[red] (-3, -3) rectangle (-2.6, -2.6);
    \end{scope}
\end{tikzpicture}
\]


\item Алгоритм повторяет шаги 2-5,  пока каждому образцу не будет соответствовать свой отдельный кластер.

\[
\begin{tikzpicture}
        \begin{scope}[yshift=-9cm]
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);

        \draw (-2.8, -2.8) circle (0.12);
        \draw (-1.75, 2.8) circle (0.12);
        \draw (1, 2.5) circle (0.12);
        \draw (1.9, 1) circle (0.12);
        \draw (1, -1.5) circle (0.12);
        \draw (1.8, -2) circle (0.12);

        
        \draw[blue] (-1.95, 3) rectangle (-1.55, 2.6);
        \draw[red] (-3, -3) rectangle (-2.6, -2.6);
        \draw[green] (0.8, 2.7) rectangle (1.2, 2.3);
        \draw[black] (1.7, 1.2) rectangle (2.1, 0.8);
        \draw[magenta] (0.8, -1.3) rectangle (1.2, -1.7);
        \draw[cyan] (1.6, -1.8) rectangle (2, -2.2);
    \end{scope}
\end{tikzpicture}
\]

\end{enumerate}

Подсчитать среднюю схожесть образцов в исходном кластере с остальными объектами этого кластера и вычесть из нее схожесть данного объекта с образцами в новом кластере. Если эта величина окажется отрицательной, перенести
этот объект в новый кластер.
\[
\begin{tikzpicture}
\node (a) at (-6,0) {a};
\node (b) at (-3,0) {b};
\node (c) at (-0.5,0) {c};
\node (d) at (0.5,0) {d};
\node (e) at (1.5,0) {e};
\node (f) at (2.5,0) {f};

\node[blue] (ab) at (-4.5,2.5) {};
\node (cd) at (0,1) {};
\node (ef) at (2,1) {};
\node (cdef) at (1,2.5) {};
\node (all) at (-1.5,5) {};

\draw[blue]  (a) |- (ab.center);
\draw[blue]  (b) |- (ab.center);
\draw[red]  (c) |- (cd.center);
\draw[red]  (d) |- (cd.center);
\draw[red]  (e) |- (ef.center);
\draw[red]  (f) |- (ef.center);

\draw[red]  (cd.center) |- (cdef.center);
\draw[red]  (ef.center) |- (cdef.center);
\draw  (ab.center) |- (all.center);
\draw  (cdef.center) |- (all.center);
\end{tikzpicture}
\]

\input{dbscan.tex}

\end{document}
