\documentclass[12pt, a4paper]{article}

\usepackage{cmap}					
\usepackage[T2A]{fontenc}		
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{tikz}
\title{Иерархическая кластеризация}


\begin{document}
\maketitle
Иерархическая кластеризация выводит иерархию, структуру, которая является более информативной, чем неструктурированный набор кластеров, возвращаемых плоской кластеризацией. Иерархическая кластеризация не требует заранее определять количество кластеров, и большинство популярных иерархических алгоритмов является детерминированными. Наиболее распространенные алгоритмы иерархической кластеризации имеют сложность, которая является по меньшей мере квадратичной по количеству документов по сравнению с линейной сложностью K-средних и EM-алгоритма.

Существует два подхода решения задачи иерархической кластеризации – восходящий и нисходящий. Восходящий алгоритм присваивает каждому образцу отдельный кластер, 
а затем объединяет пары наиболее похожих друг на друга кластеров в один, пока не получит кластер со всеми объектами внутри. Нисходящий алгоритм наоборот: 
начинает с большого кластера и далее рекурсивно разделяет кластеры, пока в каждом кластере не будет по одному объекту.
Часто иерархическую кластеризацию представляют в форме дендрограм, 
где схожие объекты содержатся в одинаковых ветвях. Для перевода результата иерархической кластеризации в плоский вид необходимо сделать разрез на определенном уровне. Существует несколько правил для выбора уровня разреза:

\begin{itemize}
\item Совершать разрез на данном уровне схожести.
\item Сделать разрез там, где разница между двумя уровнями схожести, в случае разреза, будет максимальной.
\item Зафиксировать строгое количество K кластеров и выбрать соответствующий уровень для разделения.
\end{itemize}
   
\section*{Восходящая кластеризация}
Для начала стоит ввести такое понятие, как расстояние между точками. Существует несколько способов определения расстояний, но наиболее популярно евклидово расстояние, которое и будет далее использоваться:

\[
\||a-b||_2 = \sqrt{\sum_i (a_i-b_i)^2}
\]

Также существует несколько алгоритмов для определения схожести кластеров:

\begin{itemize}
\item Односвязная кластеризация. В этом подходе схожесть двух кластеров определяется как схожесть их двух наиболее похожих друг на друга элементов:
\[
\ d(C_i, C_j) =  \min_{x_i \in C_i, x_j \in C_j} ||x_i - x_j||
\]
где d - некоторая функция схожести, $C_{i, j}$ - два кластера и $x_{i, j}$ - две точки, взятые из каждого кластера. При таком подходе уделяется внимание лишь тем областям, в которых кластеры наиболее близки; игнорируются другие части и общая структура.
\item Полносвязная кластеризация. В этом подходе схожесть двух кластеров определяется как схожесть их двух наиболее различающихся элементов:
\[
\ d(C_i, C_j) =  \max_{x_i \in C_i, x_j \in C_j} ||x_i - x_j||
\]
Данный подход позволяет создавать компактные кластеры; чувствителен к выбросам.
\item Среднегрупповая кластеризация. В данном алгоритме учитывается схожесть всех образцов в кластерах, подсчитывая величину:
\[
\ d(C_i, C_j) = \frac{1}{n_{i}n_{j}}{\mit\Sigma}_{x_i \in C_i}{\mit\Sigma}_{x_j \in C_j}||x_i - x_j||
\]
Такой подход позволяет получить когерентные кластеры
\item Метод центроидов. В этом подходе схожесть двух кластеров определяется как схожесть их центроидов $\mu(w_{i,j})$, причем за функцию расстояния берется евклидово расстояние:
\[
\ d(C_i, C_j) =||\mu(w_i)-\mu(w_j)||
\]
\end{itemize}

\section*{Нисходящая кластеризация}

Дивизимные или нисходящие алгоритмы кластеризации разделяют один большой кластер на мелкие, до тех пор, пока в каждом кластере не останется по одному образцу. Для перевода иерархической кластеризации в плоскую, необходимо сделать разрез на каком-то уровне дендрограмы. 

Правила для выбора уровня разреза:
\begin{itemize} 
\item Зафиксировать количество кластеров.


\item Совершать разрез на определенном уровне дендрограмы. 


\item Совершать разрез, когда разница схожести между уровнями максимальна. 
\end{itemize}

Алгоритм выполняет следующие шаги:
\begin{enumerate}


\item Присвоить всем объектам один кластер.


\item Найти объект, который похож меньше всего на остальные и отделить его в отельный кластер.


\item В исходном кластере подсчитать среднюю схожесть с остальными объектами кластера и вычесть схожесть данного объекта с образцами в новом кластере. В случае, если величина отрицательна, этот объект переносится в новый кластер. В качестве метрики схожести используем евклидово расстояние.

\item Повторить предыдущий шаг до тех пор, пока не останется объектов с отрицательной разностью.

\item Повторить шаги 2-4 для кластеров с наибольшим диаметром.

\item Повторить шаги 2-5 до тех пор, пока каждый объект не будет соответствовать отдельному кластеру.
\end{enumerate}

\[
\begin{tikzpicture}
    \begin{scope}
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);
        
        \draw (2.5, 2.5) circle (0.12);
        \draw (1.35, 2.25) circle (0.12);
        \draw (1.6, 1.1) circle (0.12);
        \draw (1.95, 1.9) circle (0.12);
        \draw (-2.4, -1.9) circle (0.12);
        \draw (-1.8, -1.3) circle (0.12);
        \draw (-1.95, 2.11) circle (0.12);
        \draw (2.6, -2.4) circle (0.12);
        
        \draw[red] (-2.7, -2.7) rectangle (2.8, 2.85);
    \end{scope}
    \begin{scope}[xshift=7.5cm]
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);
        
        \draw (2.5, 2.5) circle (0.12);
        \draw (1.35, 2.25) circle (0.12);
        \draw (1.6, 1.1) circle (0.12);
        \draw (1.95, 1.9) circle (0.12);
        \draw (-2.4, -1.9) circle (0.12);
        \draw (-1.8, -1.3) circle (0.12);
        \draw (-1.95, 2.11) circle (0.12);
        \draw (2.6, -2.4) circle (0.12);
        
        \draw[red] (-2.3, 0.83) rectangle (2.8, 2.8);
        \draw[blue] (-2.7, -2.1) rectangle (-1.5, -1.1);
        \draw[green] (2.2, -2.8) rectangle (3, -2);
    \end{scope}
    \begin{scope}[yshift=-9cm]
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);
        
        \draw (2.5, 2.5) circle (0.12);
        \draw (1.35, 2.25) circle (0.12);
        \draw (1.6, 1.1) circle (0.12);
        \draw (1.95, 1.9) circle (0.12);
        \draw (-2.4, -1.9) circle (0.12);
        \draw (-1.8, -1.3) circle (0.12);
        \draw (-1.95, 2.11) circle (0.12);
        \draw (2.6, -2.4) circle (0.12);
        
        \draw[blue] (-2.7, -2.1) rectangle (-1.5, -1.1);
        \draw[green] (2.2, -2.8) rectangle (3, -2);
        \draw[red] (1, 0.83) rectangle (2.8, 2.8);
        \draw[green] (-2.4, 1.6) rectangle (-1.5, 2.55);
    \end{scope}
    \begin{scope}[yshift=-9cm, xshift=7.5cm]
        \draw (-3.5, 3.5) -- (3.5, 3.5);
        \draw (-3.5, -3.5) -- (3.5, -3.5);
        \draw (-3.5, -3.5) -- (-3.5, 3.5);
        \draw (3.5, 3.5) -- (3.5, -3.5);
        
        \draw (2.5, 2.5) circle (0.12);
        \draw (1.35, 2.25) circle (0.12);
        \draw (1.6, 1.1) circle (0.12);
        \draw (1.95, 1.9) circle (0.12);
        \draw (-2.4, -1.9) circle (0.12);
        \draw (-1.8, -1.3) circle (0.12);
        \draw (-1.95, 2.11) circle (0.12);
        \draw (2.6, -2.4) circle (0.12);
        
        \draw (-2.6, -2.15) rectangle (-2.15, -1.64);
        \draw (-2.05, -1.55) rectangle (-1.55, -1.1);
        \draw[green] (2.2, -2.8) rectangle (3, -2);
        \draw (2.2, 2.2) rectangle (2.8, 2.8);
        \draw[red] (1.023, 1.9) rectangle (1.63, 2.57);
        \draw (1.73, 1.64) rectangle (2.17, 2.13);
        \draw (1.35, 0.83) rectangle (1.85, 1.38);
        \draw[green] (-2.4, 1.6) rectangle (-1.5, 2.55);
    \end{scope}
\end{tikzpicture}
\]

\end{document}
